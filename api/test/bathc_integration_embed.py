# -*- coding: utf-8 -*-
"""Bathc_Integration_embed.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SHyVSc1eJsVUEPBFRbwSpZVzpjDlftkf
"""

import json
import pandas as pd

# Load data from JSON
with open('results.json') as file:
    data = json.load(file)

# Normalize data
df = pd.json_normalize(data)

# Specify the columns you want to keep
columns_to_keep = ['method_id', 'mean_score'] + [col for col in df.columns if col.startswith('metric_values.')]

# Filter the DataFrame to keep only the specified columns
df = df[columns_to_keep]

# Group by 'method_id' and calculate mean for each group
df_1 = df.groupby('method_id', as_index=True).mean()

#print(df_1)

# Load data from JSON
with open('results.json') as file:
    data = json.load(file)

# Normalize and create a DataFrame
df = pd.json_normalize(data)

# Calculate mean scores for scaled scores
scaled_score_columns = [col for col in df if col.startswith('scaled_scores.')]
df['mean_scaled_scores'] = df[scaled_score_columns].mean(axis=1)

# Calculate mean scores for each metric
metric_columns = [col for col in df if col.startswith('metric_values.')]
for metric in metric_columns:
    df[metric] = df[metric].astype(float)  # Ensure the metrics are floats
df['mean_metric_scores'] = df[metric_columns].mean(axis=1)

# Aggregate mean scores per dataset and method
df_grouped = df.groupby(['method_id', 'dataset_id']).agg(
    mean_scaled_scores=('mean_scaled_scores', 'mean'),
    mean_metric_scores=('mean_metric_scores', 'mean')
).reset_index()


# Pivot the table to have datasets as columns
df_pivoted = df_grouped.pivot(index='method_id', columns='dataset_id', values=['mean_scaled_scores'])

#print(df_pivoted)

# Assuming df_pivoted is your pivot table
# Flattening the multi-level column index, while keeping 'method_id' as index
df_2 = df_pivoted.copy()
df_2.aggregatecolumns = ['_'.join(col).strip() if col[0] != '' else col[1] for col in df_2.columns.values]

# Now df_flattened is a regular DataFrame with 'method_id' as the index

combined_df = pd.concat([df_2, df_1], axis=1)
combined_df = combined_df.reset_index()
combined_df.columns = ['Name','immune', 'lung', 'pancreas', 'Score', 'ARI', 'CC Score', 'Graph Connectivity', 'isolated labels f1', 'isolated labels sil', 'kBET', 'nmi', 'pcr', 'silhouette', 'silhouette batch']
# Define the new column order
new_order = ['Name', 'Score', 'immune', 'lung', 'pancreas', 'ARI', 'CC Score', 'Graph Connectivity', 'isolated labels f1', 'isolated labels sil', 'kBET', 'nmi', 'pcr', 'silhouette', 'silhouette batch']

# Reorder the columns in the DataFrame
combined_df = combined_df[new_order]
print(combined_df)

import plotly.graph_objects as go

# Normalize your numeric data columns for color scaling
numeric_cols = combined_df.select_dtypes(include='float').columns

# Define the size range for your circles
size_range = [10, 15]  # Minimum and maximum size of circles

# Create figure
fig = go.Figure()

# Define your colors
dataset_colors = 'ice'
metric_colors = 'oranges'


# Add circles for each metric value
for i, col in enumerate(numeric_cols, 1):  # Start the enumeration at 1 for positioning
    # Ensure sizes are non-negative
    sizes = (combined_df[col] - combined_df[col].min()) / (combined_df[col].max() - combined_df[col].min())
    sizes = sizes * (size_range[1] - size_range[0]) + size_range[0]

    if col in ['immune', 'lung', 'pancreas']:
        color = dataset_colors
    else:
        color = metric_colors

    if col== 'Score':
      fig.add_trace(go.Scatter(
        x=[col] * len(combined_df),  # The x values are the names of the metrics
        y=combined_df.index,  # The y values are the names of the methods
        mode='markers',
        marker=dict(
            size=sizes,
            color=combined_df[col],  # Actual values for colors
            colorscale=color,  # Set colorscale
            coloraxis='coloraxis',
        ),
        hoverinfo='text',
        text=combined_df[col].round(4).astype(str),  # Rounded value for display
        name=col
    ))

    else:

      fig.add_trace(go.Scatter(
        x=[col] * len(combined_df),  # The x values are the names of the metrics
        y=combined_df.index,  # The y values are the names of the methods
        mode='markers',
        marker=dict(
            size=sizes,
            color=combined_df[col],  # Actual values for colors
            colorscale=color,  # Set colorscale
        ),
        hoverinfo='text',
        text=combined_df[col].round(4).astype(str),  # Rounded value for display
        name=col
    ))

# Update layout
fig.update_layout(
    title='Data Visualization',
    xaxis=dict(
        tickmode='array',
        tickvals=list(numeric_cols),  # Positioning on the x-axis
        ticktext=list(numeric_cols),  # Column names as tick text
        side='top',
        tickangle=-45,  # Slant the column names
    ),
    yaxis=dict(
        tickmode='array',
        tickvals=combined_df.index,
        ticktext=combined_df['Name'],
        autorange='reversed'
    ),
    height=900,  # Adjust height to fit the number of rows
    width=1100,  # Adjust width to fit the number of metrics
    plot_bgcolor='white',  # Set background to white for clarity
    margin=dict(l=200, r=100, t=100, b=150),  # Adjust margins to fit names and
    coloraxis=dict(colorscale='gray'),  # Define the colorscale
    coloraxis_colorbar=dict(
        title='score',
        orientation='h',
        x=0.5,
        xanchor='center',
        y=-0.1,
        lenmode='fraction',
        len=0.75),
)



# Show figure
fig.show()

import plotly.graph_objects as go

# Assuming combined_df is your DataFrame
fig = go.Figure(data=[go.Table(
    header=dict(values=list(combined_df.columns),
                fill_color='paleturquoise',
                align='left'),
    cells=dict(values=[combined_df[col] for col in combined_df.columns],
               fill_color='lavender',
               align='left'))
])

fig.show()

"""Visualization of raw-data"""

import plotly.graph_objects as go
import pandas as pd
import json

# Load the JSON data into a DataFrame
with open('results.json') as f:
    data = json.load(f)

# Flatten the data and create a DataFrame
df = pd.json_normalize(data)

# Extract the 'graph_connectivity' values along with 'method_id' and 'dataset_id'
graph_connectivity_df = df[['method_id', 'dataset_id', 'metric_values.graph_connectivity']]

# Pivot the DataFrame to have 'method_id' as index and 'dataset_id' as columns
df_pivoted = graph_connectivity_df.pivot(index='method_id', columns='dataset_id', values='metric_values.graph_connectivity')


# Assuming 'flat_df3' is the pivoted DataFrame you want to flatten
flat_df3 = df_pivoted.reset_index()

# If 'flat_df3' had multi-level columns after pivoting, you might want to flatten them like so:
flat_df3.columns = ['_'.join(col).strip() if type(col) is tuple else col for col in flat_df3.columns.values]

# Now 'flat_df' is a flattened DataFrame with single-level columns
#print(flat_df3)

# Create figure
fig = go.Figure()

# Assuming 'method_id' is a column in your dataframe and you want it on the y-axis
method_ids = flat_df3['method_id'].values  # Replace with combined_df.index if 'method_id' is the index

# Add traces for each graph_connectivity dataset
for graph_connectivity_dataset in ['immune_batch', 'lung_batch', 'pancreas_batch']:
    graph_connectivity_values = flat_df3[graph_connectivity_dataset].values

    fig.add_trace(go.Scatter(
        x=graph_connectivity_values,
        y=method_ids,
        mode='markers+lines',
        marker=dict(color='rosybrown', size=10),
        line=dict(color='lightgray'),
        name=graph_connectivity_dataset
    ))


# Update the layout to display all method IDs
fig.update_layout(
    title="Graph_connectivity Values for Different Datasets",
    xaxis_title="Graph_connectivity Metric Values",
    yaxis_title="Method ID",
    xaxis=dict(range=[0, 1]),
    yaxis=dict(
        tickmode='array',
        tickvals=list(range(len(method_ids))),
        ticktext=method_ids,
        autorange='reversed'  # Reverse the y-axis
    ),
    margin=dict(t=100, b=100)  # Increase the top and bottom margin size
)

# Modify the figure size if needed
fig.update_layout(height=1000)  # Adjust the height as needed

# Show the figure
fig.show()

import plotly.graph_objects as go
import pandas as pd
import json

# Load the JSON data into a DataFrame
with open('results.json') as f:
    data = json.load(f)

# Flatten the data and create a DataFrame
df = pd.json_normalize(data)

# Extract the 'isolated_label_f1' values along with 'method_id' and 'dataset_id'
isolated_label_f1_df = df[['method_id', 'dataset_id', 'metric_values.isolated_labels_f1']]

# Pivot the DataFrame to have 'method_id' as index and 'dataset_id' as columns
df_pivoted = isolated_label_f1_df.pivot(index='method_id', columns='dataset_id', values='metric_values.isolated_labels_f1')


# Assuming 'df_pivoted' is the pivoted DataFrame you want to flatten
flat_df4 = df_pivoted.reset_index()

# If 'cc_score_pivoted' had multi-level columns after pivoting, you might want to flatten them like so:
flat_df4.columns = ['_'.join(col).strip() if type(col) is tuple else col for col in flat_df4.columns.values]

# Now 'flat_df' is a flattened DataFrame with single-level columns
#print(flat_df4)
# Create figure
fig = go.Figure()

# Assuming 'method_id' is a column in your dataframe and you want it on the y-axis
method_ids = flat_df4['method_id'].values  # Replace with combined_df.index if 'method_id' is the index

# Add traces for each ARI dataset
for isolated_label_f1_dataset in ['immune_batch', 'lung_batch', 'pancreas_batch']:
    isolated_label_f1_values = flat_df4[isolated_label_f1_dataset].values

    fig.add_trace(go.Scatter(
        x=isolated_label_f1_values,
        y=method_ids,
        mode='markers+lines',
        marker=dict(color='rosybrown', size=10),
        line=dict(color='lightgray'),
        name=isolated_label_f1_dataset
    ))


# Update the layout to display all method IDs
fig.update_layout(
    title="Isolated_labels_f1 Values for Different Datasets",
    xaxis_title="Isolated_labels_f1 Metric Values",
    yaxis_title="Method ID",
    xaxis=dict(range=[0, 1]),
    yaxis=dict(
        tickmode='array',
        tickvals=list(range(len(method_ids))),
        ticktext=method_ids,
        autorange='reversed'  # Reverse the y-axis
    ),
    margin=dict(t=100, b=100)  # Increase the top and bottom margin size
)

# Modify the figure size if needed
fig.update_layout(height=1000)  # Adjust the height as needed

# Show the figure
fig.show()

import plotly.graph_objects as go
import pandas as pd
import json

# Load the JSON data into a DataFrame
with open('results.json') as f:
    data = json.load(f)

# Flatten the data and create a DataFrame
df = pd.json_normalize(data)

# Extract the 'cc_score' values along with 'method_id' and 'dataset_id'
isolated_label_sil_df = df[['method_id', 'dataset_id', 'metric_values.isolated_labels_sil']]

# Pivot the DataFrame to have 'method_id' as index and 'dataset_id' as columns
df_pivoted = isolated_label_sil_df.pivot(index='method_id', columns='dataset_id', values='metric_values.isolated_labels_sil')


# Assuming 'cc_score_pivoted' is the pivoted DataFrame you want to flatten
flat_df5 = df_pivoted.reset_index()

# If 'cc_score_pivoted' had multi-level columns after pivoting, you might want to flatten them like so:
flat_df5.columns = ['_'.join(col).strip() if type(col) is tuple else col for col in flat_df5.columns.values]

# Now 'flat_df' is a flattened DataFrame with single-level columns
#print(flat_df5)
# Create figure
fig = go.Figure()

# Assuming 'method_id' is a column in your dataframe and you want it on the y-axis
method_ids = flat_df5['method_id'].values  # Replace with combined_df.index if 'method_id' is the index

# Add traces for each ARI dataset
for isolated_label_sil_dataset in ['immune_batch', 'lung_batch', 'pancreas_batch']:
    isolated_label_sil_values = flat_df5[isolated_label_sil_dataset].values

    fig.add_trace(go.Scatter(
        x=isolated_label_sil_values,
        y=method_ids,
        mode='markers+lines',
        marker=dict(color='rosybrown', size=10),
        line=dict(color='lightgray'),
        name=isolated_label_sil_dataset
    ))


# Update the layout to display all method IDs
fig.update_layout(
    title="Isolated_labels_silhouette Values for Different Datasets",
    xaxis_title="Isolated_labels_silhouette Metric Values",
    yaxis_title="Method ID",
    xaxis=dict(range=[0, 1]),
    yaxis=dict(
        tickmode='array',
        tickvals=list(range(len(method_ids))),
        ticktext=method_ids,
        autorange='reversed'  # Reverse the y-axis
    ),
    margin=dict(t=100, b=100)  # Increase the top and bottom margin size
)

# Modify the figure size if needed
fig.update_layout(height=1000)  # Adjust the height as needed

# Show the figure
fig.show()

import plotly.graph_objects as go
import pandas as pd
import json

# Load the JSON data into a DataFrame
with open('results.json') as f:
    data = json.load(f)

# Flatten the data and create a DataFrame
df = pd.json_normalize(data)

# Extract the 'cc_score' values along with 'method_id' and 'dataset_id'
kbet_df = df[['method_id', 'dataset_id', 'metric_values.kBET']]

# Pivot the DataFrame to have 'method_id' as index and 'dataset_id' as columns
df_pivoted = kbet_df.pivot(index='method_id', columns='dataset_id', values='metric_values.kBET')


# Assuming 'cc_score_pivoted' is the pivoted DataFrame you want to flatten
flat_df6 = df_pivoted.reset_index()

# If 'cc_score_pivoted' had multi-level columns after pivoting, you might want to flatten them like so:
flat_df6.columns = ['_'.join(col).strip() if type(col) is tuple else col for col in flat_df6.columns.values]

# Now 'flat_df' is a flattened DataFrame with single-level columns
#print(flat_df6)
# Create figure
fig = go.Figure()

# Assuming 'method_id' is a column in your dataframe and you want it on the y-axis
method_ids = flat_df6['method_id'].values  # Replace with combined_df.index if 'method_id' is the index

# Add traces for each ARI dataset
for kbet_dataset in ['immune_batch', 'lung_batch', 'pancreas_batch']:
    kbet_values = flat_df6[kbet_dataset].values

    fig.add_trace(go.Scatter(
        x=kbet_values,
        y=method_ids,
        mode='markers+lines',
        marker=dict(color='rosybrown', size=10),
        line=dict(color='lightgray'),
        name=kbet_dataset
    ))


# Update the layout to display all method IDs
fig.update_layout(
    title="kBET Values for Different Datasets",
    xaxis_title="kBET Metric Values",
    yaxis_title="Method ID",
    xaxis=dict(range=[-0.1, 1.1]),
    yaxis=dict(
        tickmode='array',
        tickvals=list(range(len(method_ids))),
        ticktext=method_ids,
        autorange='reversed'  # Reverse the y-axis
    ),
    margin=dict(t=100, b=100)  # Increase the top and bottom margin size
)

# Modify the figure size if needed
fig.update_layout(height=1000)  # Adjust the height as needed

# Show the figure
fig.show()

import plotly.graph_objects as go
import pandas as pd
import json

# Load the JSON data into a DataFrame
with open('results.json') as f:
    data = json.load(f)

# Flatten the data and create a DataFrame
df = pd.json_normalize(data)

# Extract the 'cc_score' values along with 'method_id' and 'dataset_id'
nmi_df = df[['method_id', 'dataset_id', 'metric_values.nmi']]

# Pivot the DataFrame to have 'method_id' as index and 'dataset_id' as columns
df_pivoted = nmi_df.pivot(index='method_id', columns='dataset_id', values='metric_values.nmi')


# Assuming 'cc_score_pivoted' is the pivoted DataFrame you want to flatten
flat_df7 = df_pivoted.reset_index()

# If 'cc_score_pivoted' had multi-level columns after pivoting, you might want to flatten them like so:
flat_df7.columns = ['_'.join(col).strip() if type(col) is tuple else col for col in flat_df7.columns.values]

# Now 'flat_df' is a flattened DataFrame with single-level columns
#print(flat_df6)
# Create figure
fig = go.Figure()

# Assuming 'method_id' is a column in your dataframe and you want it on the y-axis
method_ids = flat_df7['method_id'].values  # Replace with combined_df.index if 'method_id' is the index

# Add traces for each ARI dataset
for nmi_dataset in ['immune_batch', 'lung_batch', 'pancreas_batch']:
    nmi_values = flat_df7[nmi_dataset].values

    fig.add_trace(go.Scatter(
        x=nmi_values,
        y=method_ids,
        mode='markers+lines',
        marker=dict(color='rosybrown', size=10),
        line=dict(color='lightgray'),
        name=nmi_dataset
    ))


# Update the layout to display all method IDs
fig.update_layout(
    title="NMI Values for Different Datasets",
    xaxis_title="NMI Metric Values",
    yaxis_title="Method ID",
    xaxis=dict(range=[-0.1, 1.1]),
    yaxis=dict(
        tickmode='array',
        tickvals=list(range(len(method_ids))),
        ticktext=method_ids,
        autorange='reversed'  # Reverse the y-axis
    ),
    margin=dict(t=100, b=100)  # Increase the top and bottom margin size
)

# Modify the figure size if needed
fig.update_layout(height=1000)  # Adjust the height as needed

# Show the figure
fig.show()

import plotly.graph_objects as go
import pandas as pd
import json

# Load the JSON data into a DataFrame
with open('results.json') as f:
    data = json.load(f)

# Flatten the data and create a DataFrame
df = pd.json_normalize(data)

# Extract the 'cc_score' values along with 'method_id' and 'dataset_id'
pcr_df = df[['method_id', 'dataset_id', 'metric_values.pcr']]

# Pivot the DataFrame to have 'method_id' as index and 'dataset_id' as columns
df_pivoted = pcr_df.pivot(index='method_id', columns='dataset_id', values='metric_values.pcr')


# Assuming 'cc_score_pivoted' is the pivoted DataFrame you want to flatten
flat_df8 = df_pivoted.reset_index()

# If 'cc_score_pivoted' had multi-level columns after pivoting, you might want to flatten them like so:
flat_df8.columns = ['_'.join(col).strip() if type(col) is tuple else col for col in flat_df8.columns.values]

# Now 'flat_df' is a flattened DataFrame with single-level columns
#print(flat_df6)
# Create figure
fig = go.Figure()

# Assuming 'method_id' is a column in your dataframe and you want it on the y-axis
method_ids = flat_df8['method_id'].values  # Replace with combined_df.index if 'method_id' is the index

# Add traces for each ARI dataset
for pcr_dataset in ['immune_batch', 'lung_batch', 'pancreas_batch']:
    pcr_values = flat_df8[pcr_dataset].values

    fig.add_trace(go.Scatter(
        x=pcr_values,
        y=method_ids,
        mode='markers+lines',
        marker=dict(color='rosybrown', size=10),
        line=dict(color='lightgray'),
        name=pcr_dataset
    ))


# Update the layout to display all method IDs
fig.update_layout(
    title="PCR Values for Different Datasets",
    xaxis_title="PCR Metric Values",
    yaxis_title="Method ID",
    xaxis=dict(range=[-0.1, 1.1]),
    yaxis=dict(
        tickmode='array',
        tickvals=list(range(len(method_ids))),
        ticktext=method_ids,
        autorange='reversed'  # Reverse the y-axis
    ),
    margin=dict(t=100, b=100)  # Increase the top and bottom margin size
)

# Modify the figure size if needed
fig.update_layout(height=1000)  # Adjust the height as needed

# Show the figure
fig.show()

import plotly.graph_objects as go
import pandas as pd
import json

# Load the JSON data into a DataFrame
with open('results.json') as f:
    data = json.load(f)

# Flatten the data and create a DataFrame
df = pd.json_normalize(data)

# Extract the 'cc_score' values along with 'method_id' and 'dataset_id'
silhouette_df = df[['method_id', 'dataset_id', 'metric_values.silhouette']]

# Pivot the DataFrame to have 'method_id' as index and 'dataset_id' as columns
df_pivoted = silhouette_df.pivot(index='method_id', columns='dataset_id', values='metric_values.silhouette')


# Assuming 'cc_score_pivoted' is the pivoted DataFrame you want to flatten
flat_df9 = df_pivoted.reset_index()

# If 'cc_score_pivoted' had multi-level columns after pivoting, you might want to flatten them like so:
flat_df9.columns = ['_'.join(col).strip() if type(col) is tuple else col for col in flat_df9.columns.values]

# Now 'flat_df' is a flattened DataFrame with single-level columns
#print(flat_df6)
# Create figure
fig = go.Figure()

# Assuming 'method_id' is a column in your dataframe and you want it on the y-axis
method_ids = flat_df9['method_id'].values  # Replace with combined_df.index if 'method_id' is the index

# Add traces for each ARI dataset
for silhouette_dataset in ['immune_batch', 'lung_batch', 'pancreas_batch']:
    silhouette_values = flat_df9[silhouette_dataset].values

    fig.add_trace(go.Scatter(
        x=silhouette_values,
        y=method_ids,
        mode='markers+lines',
        marker=dict(color='rosybrown', size=10),
        line=dict(color='lightgray'),
        name=silhouette_dataset
    ))


# Update the layout to display all method IDs
fig.update_layout(
    title="Silhouette Values for Different Datasets",
    xaxis_title="silhouette Metric Values",
    yaxis_title="Method ID",
    xaxis=dict(range=[-0.1, 1.1]),
    yaxis=dict(
        tickmode='array',
        tickvals=list(range(len(method_ids))),
        ticktext=method_ids,
        autorange='reversed'  # Reverse the y-axis
    ),
    margin=dict(t=100, b=100)  # Increase the top and bottom margin size
)

# Modify the figure size if needed
fig.update_layout(height=1000)  # Adjust the height as needed

# Show the figure
fig.show()

import plotly.graph_objects as go
import pandas as pd
import json

# Load the JSON data into a DataFrame
with open('results.json') as f:
    data = json.load(f)

# Flatten the data and create a DataFrame
df = pd.json_normalize(data)

# Extract the 'cc_score' values along with 'method_id' and 'dataset_id'
silhouette_batch_df = df[['method_id', 'dataset_id', 'metric_values.silhouette_batch']]

# Pivot the DataFrame to have 'method_id' as index and 'dataset_id' as columns
df_pivoted = silhouette_batch_df.pivot(index='method_id', columns='dataset_id', values='metric_values.silhouette_batch')


# Assuming 'cc_score_pivoted' is the pivoted DataFrame you want to flatten
flat_df10 = df_pivoted.reset_index()

# If 'cc_score_pivoted' had multi-level columns after pivoting, you might want to flatten them like so:
flat_df10.columns = ['_'.join(col).strip() if type(col) is tuple else col for col in flat_df10.columns.values]

# Now 'flat_df' is a flattened DataFrame with single-level columns
#print(flat_df6)
# Create figure
fig = go.Figure()

# Assuming 'method_id' is a column in your dataframe and you want it on the y-axis
method_ids = flat_df10['method_id'].values  # Replace with combined_df.index if 'method_id' is the index

# Add traces for each ARI dataset
for silhouette_batch_dataset in ['immune_batch', 'lung_batch', 'pancreas_batch']:
    silhouette_batch_values = flat_df10[silhouette_batch_dataset].values

    fig.add_trace(go.Scatter(
        x=silhouette_batch_values,
        y=method_ids,
        mode='markers+lines',
        marker=dict(color='rosybrown', size=10),
        line=dict(color='lightgray'),
        name=silhouette_batch_dataset
    ))


# Update the layout to display all method IDs
fig.update_layout(
    title="Silhouette Batch Values for Different Datasets",
    xaxis_title="silhouette_batch Metric Values",
    yaxis_title="Method ID",
    xaxis=dict(range=[-0.1, 1.1]),
    yaxis=dict(
        tickmode='array',
        tickvals=list(range(len(method_ids))),
        ticktext=method_ids,
        autorange='reversed'  # Reverse the y-axis
    ),
    margin=dict(t=100, b=100)  # Increase the top and bottom margin size
)

# Modify the figure size if needed
fig.update_layout(height=1000)  # Adjust the height as needed

# Show the figure
fig.show()